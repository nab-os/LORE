#ifndef B3_UPDATE_AABBS_H
#define B3_UPDATE_AABBS_H
#ifndef B3_AABB_H
#define B3_AABB_H
#ifndef B3_FLOAT4_H
#define B3_FLOAT4_H
#ifndef B3_PLATFORM_DEFINITIONS_H
#define B3_PLATFORM_DEFINITIONS_H
struct MyTest
{
	int bla;
};
#ifdef __cplusplus
#else
//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX
#define B3_LARGE_FLOAT 1e18f
#define B3_INFINITY 1e18f
#define b3Assert(a)
#define b3ConstArray(a) __global const a*
#define b3AtomicInc atomic_inc
#define b3AtomicAdd atomic_add
#define b3Fabs fabs
#define b3Sqrt native_sqrt
#define b3Sin native_sin
#define b3Cos native_cos
#endif
#endif
#ifdef __cplusplus
#else
	typedef float4	b3Float4;
	#define b3Float4ConstArg const b3Float4
	#define b3MakeFloat4 (float4)
	float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)
	{
		float4 a1 = b3MakeFloat4(v0.xyz,0.f);
		float4 b1 = b3MakeFloat4(v1.xyz,0.f);
		return dot(a1, b1);
	}
	b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)
	{
		float4 a1 = b3MakeFloat4(v0.xyz,0.f);
		float4 b1 = b3MakeFloat4(v1.xyz,0.f);
		return cross(a1, b1);
	}
	#define b3MinFloat4 min
	#define b3MaxFloat4 max
	#define b3Normalized(a) normalize(a)
#endif 
		
inline bool b3IsAlmostZero(b3Float4ConstArg v)
{
	if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)	
		return false;
	return true;
}
inline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )
{
    float maxDot = -B3_INFINITY;
    int i = 0;
    int ptIndex = -1;
    for( i = 0; i < vecLen; i++ )
    {
        float dot = b3Dot3F4(vecArray[i],vec);
            
        if( dot > maxDot )
        {
            maxDot = dot;
            ptIndex = i;
        }
    }
	b3Assert(ptIndex>=0);
    if (ptIndex<0)
	{
		ptIndex = 0;
	}
    *dotOut = maxDot;
    return ptIndex;
}
#endif //B3_FLOAT4_H
#ifndef B3_MAT3x3_H
#define B3_MAT3x3_H
#ifndef B3_QUAT_H
#define B3_QUAT_H
#ifndef B3_PLATFORM_DEFINITIONS_H
#ifdef __cplusplus
#else
#endif
#endif
#ifndef B3_FLOAT4_H
#ifdef __cplusplus
#else
#endif 
#endif //B3_FLOAT4_H
#ifdef __cplusplus
#else
	typedef float4	b3Quat;
	#define b3QuatConstArg const b3Quat
	
	
inline float4 b3FastNormalize4(float4 v)
{
	v = (float4)(v.xyz,0.f);
	return fast_normalize(v);
}
	
inline b3Quat b3QuatMul(b3Quat a, b3Quat b);
inline b3Quat b3QuatNormalized(b3QuatConstArg in);
inline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);
inline b3Quat b3QuatInvert(b3QuatConstArg q);
inline b3Quat b3QuatInverse(b3QuatConstArg q);
inline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)
{
	b3Quat ans;
	ans = b3Cross3( a, b );
	ans += a.w*b+b.w*a;
//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);
	ans.w = a.w*b.w - b3Dot3F4(a, b);
	return ans;
}
inline b3Quat b3QuatNormalized(b3QuatConstArg in)
{
	b3Quat q;
	q=in;
	//return b3FastNormalize4(in);
	float len = native_sqrt(dot(q, q));
	if(len > 0.f)
	{
		q *= 1.f / len;
	}
	else
	{
		q.x = q.y = q.z = 0.f;
		q.w = 1.f;
	}
	return q;
}
inline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)
{
	b3Quat qInv = b3QuatInvert( q );
	float4 vcpy = vec;
	vcpy.w = 0.f;
	float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);
	return out;
}
inline b3Quat b3QuatInverse(b3QuatConstArg q)
{
	return (b3Quat)(-q.xyz, q.w);
}
inline b3Quat b3QuatInvert(b3QuatConstArg q)
{
	return (b3Quat)(-q.xyz, q.w);
}
inline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)
{
	return b3QuatRotate( b3QuatInvert( q ), vec );
}
inline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)
{
	return b3QuatRotate( orientation, point ) + (translation);
}
	
#endif 
#endif //B3_QUAT_H
#ifdef __cplusplus
#else
typedef struct
{
	b3Float4 m_row[3];
}b3Mat3x3;
#define b3Mat3x3ConstArg const b3Mat3x3
#define b3GetRow(m,row) (m.m_row[row])
inline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)
{
	b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);
	b3Mat3x3 out;
	out.m_row[0].x=1-2*quat2.y-2*quat2.z;
	out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;
	out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;
	out.m_row[0].w = 0.f;
	out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;
	out.m_row[1].y=1-2*quat2.x-2*quat2.z;
	out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;
	out.m_row[1].w = 0.f;
	out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;
	out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;
	out.m_row[2].z=1-2*quat2.x-2*quat2.y;
	out.m_row[2].w = 0.f;
	return out;
}
inline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)
{
	b3Mat3x3 out;
	out.m_row[0] = fabs(matIn.m_row[0]);
	out.m_row[1] = fabs(matIn.m_row[1]);
	out.m_row[2] = fabs(matIn.m_row[2]);
	return out;
}
__inline
b3Mat3x3 mtZero();
__inline
b3Mat3x3 mtIdentity();
__inline
b3Mat3x3 mtTranspose(b3Mat3x3 m);
__inline
b3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);
__inline
b3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);
__inline
b3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);
__inline
b3Mat3x3 mtZero()
{
	b3Mat3x3 m;
	m.m_row[0] = (b3Float4)(0.f);
	m.m_row[1] = (b3Float4)(0.f);
	m.m_row[2] = (b3Float4)(0.f);
	return m;
}
__inline
b3Mat3x3 mtIdentity()
{
	b3Mat3x3 m;
	m.m_row[0] = (b3Float4)(1,0,0,0);
	m.m_row[1] = (b3Float4)(0,1,0,0);
	m.m_row[2] = (b3Float4)(0,0,1,0);
	return m;
}
__inline
b3Mat3x3 mtTranspose(b3Mat3x3 m)
{
	b3Mat3x3 out;
	out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);
	out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);
	out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);
	return out;
}
__inline
b3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)
{
	b3Mat3x3 transB;
	transB = mtTranspose( b );
	b3Mat3x3 ans;
	//	why this doesn't run when 0ing in the for{}
	a.m_row[0].w = 0.f;
	a.m_row[1].w = 0.f;
	a.m_row[2].w = 0.f;
	for(int i=0; i<3; i++)
	{
//	a.m_row[i].w = 0.f;
		ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);
		ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);
		ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);
		ans.m_row[i].w = 0.f;
	}
	return ans;
}
__inline
b3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)
{
	b3Float4 ans;
	ans.x = b3Dot3F4( a.m_row[0], b );
	ans.y = b3Dot3F4( a.m_row[1], b );
	ans.z = b3Dot3F4( a.m_row[2], b );
	ans.w = 0.f;
	return ans;
}
__inline
b3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)
{
	b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);
	b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);
	b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);
	b3Float4 ans;
	ans.x = b3Dot3F4( a, colx );
	ans.y = b3Dot3F4( a, coly );
	ans.z = b3Dot3F4( a, colz );
	return ans;
}
#endif
#endif //B3_MAT3x3_H
typedef struct b3Aabb b3Aabb_t;
struct b3Aabb
{
	union
	{
		float m_min[4];
		b3Float4 m_minVec;
		int m_minIndices[4];
	};
	union
	{
		float	m_max[4];
		b3Float4 m_maxVec;
		int m_signedMaxIndices[4];
	};
};
inline void b3TransformAabb2(b3Float4ConstArg localAabbMin,b3Float4ConstArg localAabbMax, float margin,
						b3Float4ConstArg pos,
						b3QuatConstArg orn,
						b3Float4* aabbMinOut,b3Float4* aabbMaxOut)
{
		b3Float4 localHalfExtents = 0.5f*(localAabbMax-localAabbMin);
		localHalfExtents+=b3MakeFloat4(margin,margin,margin,0.f);
		b3Float4 localCenter = 0.5f*(localAabbMax+localAabbMin);
		b3Mat3x3 m;
		m = b3QuatGetRotationMatrix(orn);
		b3Mat3x3 abs_b = b3AbsoluteMat3x3(m);
		b3Float4 center = b3TransformPoint(localCenter,pos,orn);
		
		b3Float4 extent = b3MakeFloat4(b3Dot3F4(localHalfExtents,b3GetRow(abs_b,0)),
										 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,1)),
										 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,2)),
										 0.f);
		*aabbMinOut = center-extent;
		*aabbMaxOut = center+extent;
}
/// conservative test for overlap between two aabbs
inline bool b3TestAabbAgainstAabb(b3Float4ConstArg aabbMin1,b3Float4ConstArg aabbMax1,
								b3Float4ConstArg aabbMin2, b3Float4ConstArg aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1.x > aabbMax2.x || aabbMax1.x < aabbMin2.x) ? false : overlap;
	overlap = (aabbMin1.z > aabbMax2.z || aabbMax1.z < aabbMin2.z) ? false : overlap;
	overlap = (aabbMin1.y > aabbMax2.y || aabbMax1.y < aabbMin2.y) ? false : overlap;
	return overlap;
}
#endif //B3_AABB_H
#ifndef B3_COLLIDABLE_H
#define B3_COLLIDABLE_H
#ifndef B3_FLOAT4_H
#ifdef __cplusplus
#else
#endif 
#endif //B3_FLOAT4_H
#ifndef B3_QUAT_H
#ifdef __cplusplus
#else
#endif 
#endif //B3_QUAT_H
enum b3ShapeTypes
{
	SHAPE_HEIGHT_FIELD=1,
	SHAPE_CONVEX_HULL=3,
	SHAPE_PLANE=4,
	SHAPE_CONCAVE_TRIMESH=5,
	SHAPE_COMPOUND_OF_CONVEX_HULLS=6,
	SHAPE_SPHERE=7,
	MAX_NUM_SHAPE_TYPES,
};
typedef struct b3Collidable b3Collidable_t;
struct b3Collidable
{
	union {
		int m_numChildShapes;
		int m_bvhIndex;
	};
	union
	{
		float m_radius;
		int	m_compoundBvhIndex;
	};
	int m_shapeType;
	union
	{
		int m_shapeIndex;
		float m_height;
	};
};
typedef struct b3GpuChildShape b3GpuChildShape_t;
struct b3GpuChildShape
{
	b3Float4	m_childPosition;
	b3Quat		m_childOrientation;
	union
	{
		int			m_shapeIndex;//used for SHAPE_COMPOUND_OF_CONVEX_HULLS
		int			m_capsuleAxis;
	};
	union 
	{
		float		m_radius;//used for childshape of SHAPE_COMPOUND_OF_SPHERES or SHAPE_COMPOUND_OF_CAPSULES
		int			m_numChildShapes;//used for compound shape
	};
	union 
	{
		float		m_height;//used for childshape of SHAPE_COMPOUND_OF_CAPSULES
		int	m_collidableShapeIndex;
	};
	int			m_shapeType;
};
struct b3CompoundOverlappingPair
{
	int m_bodyIndexA;
	int m_bodyIndexB;
//	int	m_pairType;
	int m_childShapeIndexA;
	int m_childShapeIndexB;
};
#endif //B3_COLLIDABLE_H
#ifndef B3_RIGIDBODY_DATA_H
#define B3_RIGIDBODY_DATA_H
#ifndef B3_FLOAT4_H
#ifdef __cplusplus
#else
#endif 
#endif //B3_FLOAT4_H
#ifndef B3_QUAT_H
#ifdef __cplusplus
#else
#endif 
#endif //B3_QUAT_H
#ifndef B3_MAT3x3_H
#ifdef __cplusplus
#else
#endif
#endif //B3_MAT3x3_H
typedef struct b3RigidBodyData b3RigidBodyData_t;
struct b3RigidBodyData
{
	b3Float4				m_pos;
	b3Quat					m_quat;
	b3Float4				m_linVel;
	b3Float4				m_angVel;
	int 					m_collidableIdx;
	float 				m_invMass;
	float 				m_restituitionCoeff;
	float 				m_frictionCoeff;
};
typedef struct b3InertiaData b3InertiaData_t;
struct b3InertiaData
{
	b3Mat3x3 m_invInertiaWorld;
	b3Mat3x3 m_initInvInertia;
};
#endif //B3_RIGIDBODY_DATA_H
	
void b3ComputeWorldAabb(  int bodyId, __global const b3RigidBodyData_t* bodies, __global const  b3Collidable_t* collidables, __global const  b3Aabb_t* localShapeAABB, __global b3Aabb_t* worldAabbs)
{
	__global const b3RigidBodyData_t* body = &bodies[bodyId];
	b3Float4 position = body->m_pos;
	b3Quat	orientation = body->m_quat;
	
	int collidableIndex = body->m_collidableIdx;
	int shapeIndex = collidables[collidableIndex].m_shapeIndex;
		
	if (shapeIndex>=0)
	{
				
		b3Aabb_t localAabb = localShapeAABB[collidableIndex];
		b3Aabb_t worldAabb;
		
		b3Float4 aabbAMinOut,aabbAMaxOut;	
		float margin = 0.f;
		b3TransformAabb2(localAabb.m_minVec,localAabb.m_maxVec,margin,position,orientation,&aabbAMinOut,&aabbAMaxOut);
		
		worldAabb.m_minVec =aabbAMinOut;
		worldAabb.m_minIndices[3] = bodyId;
		worldAabb.m_maxVec = aabbAMaxOut;
		worldAabb.m_signedMaxIndices[3] = body[bodyId].m_invMass==0.f? 0 : 1;
		worldAabbs[bodyId] = worldAabb;
	}
}
#endif //B3_UPDATE_AABBS_H
__kernel void initializeGpuAabbsFull(  const int numNodes, __global b3RigidBodyData_t* gBodies,__global b3Collidable_t* collidables, __global b3Aabb_t* plocalShapeAABB, __global b3Aabb_t* pAABB)
{
	int nodeID = get_global_id(0);
	if( nodeID < numNodes )
	{
		b3ComputeWorldAabb(nodeID, gBodies, collidables, plocalShapeAABB,pAABB);
	}
}
__kernel void clearOverlappingPairsKernel(  __global int4* pairs, int numPairs)
{
	int pairId = get_global_id(0);
	if( pairId< numPairs )
	{
		pairs[pairId].z = 0xffffffff;
	}
}